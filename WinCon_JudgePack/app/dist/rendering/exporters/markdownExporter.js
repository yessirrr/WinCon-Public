import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
const __dirname = dirname(fileURLToPath(import.meta.url));
const EXPORTS_DIR = join(__dirname, '../../../exports');
export async function exportToMarkdown(report) {
    // Ensure exports directory exists
    if (!existsSync(EXPORTS_DIR)) {
        mkdirSync(EXPORTS_DIR, { recursive: true });
    }
    const markdown = generateMarkdown(report);
    // Generate filename
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const safeName = report.entityName.replace(/[^a-zA-Z0-9]/g, '-');
    const filename = `${report.type}-${safeName}-${timestamp}.md`;
    const filepath = join(EXPORTS_DIR, filename);
    writeFileSync(filepath, markdown, 'utf-8');
    return filepath;
}
function generateMarkdown(report) {
    const lines = [];
    // Title
    lines.push(`# ${report.title}`);
    lines.push('');
    // Metadata
    lines.push('## Report Details');
    lines.push('');
    lines.push(`- **${report.entityType === 'team' ? 'Team' : 'Player'}**: ${report.entityName}`);
    lines.push(`- **Generated**: ${new Date(report.generatedAt).toLocaleString()}`);
    lines.push(`- **Report Type**: ${report.type}`);
    // Filters
    if (report.filters) {
        const filterParts = [];
        if (report.filters.window)
            filterParts.push(`Last ${report.filters.window} matches`);
        if (report.filters.map)
            filterParts.push(`Map: ${report.filters.map}`);
        if (report.filters.side && report.filters.side !== 'both') {
            filterParts.push(`Side: ${report.filters.side}`);
        }
        if (filterParts.length > 0) {
            lines.push(`- **Filters**: ${filterParts.join(', ')}`);
        }
    }
    lines.push('');
    // Sections
    for (const section of report.sections) {
        lines.push(`## ${section.heading}`);
        lines.push('');
        lines.push(renderContent(section.content));
        lines.push('');
    }
    // Footer
    lines.push('---');
    lines.push('');
    lines.push('*Generated by WinCon - VALORANT Scouting Console*');
    return lines.join('\n');
}
function renderContent(content) {
    switch (content.type) {
        case 'text':
            return content.value;
        case 'bullets':
            return content.items.map(item => `- ${item}`).join('\n');
        case 'table':
            return renderTable(content.headers, content.rows);
        case 'stat':
            return `**${content.label}**: ${content.value}${content.unit ? ` ${content.unit}` : ''}`;
        case 'momentum':
            return renderMomentum(content.data);
        case 'econ-intel':
            return renderEconIntel(content.data);
        default:
            return '';
    }
}
function renderTable(headers, rows) {
    const lines = [];
    // Header row
    lines.push(`| ${headers.join(' | ')} |`);
    // Separator
    lines.push(`| ${headers.map(() => '---').join(' | ')} |`);
    // Data rows
    for (const row of rows) {
        lines.push(`| ${row.join(' | ')} |`);
    }
    return lines.join('\n');
}
function formatPct(value) {
    return `${(value * 100).toFixed(0)}%`;
}
function renderMomentum(data) {
    const lines = [];
    // Aggregated summary
    lines.push(`### Aggregated (${data.aggregated.totalMaps} maps)`);
    lines.push('');
    lines.push(`- **Round Win Rate**: ${formatPct(data.aggregated.overallWinRate)}`);
    lines.push(`- **Pistol Win Rate**: ${formatPct(data.aggregated.overallPistolWinRate)}`);
    lines.push(`- **Attack Win Rate**: ${formatPct(data.aggregated.overallAttackWinRate)}`);
    lines.push(`- **Defense Win Rate**: ${formatPct(data.aggregated.overallDefenseWinRate)}`);
    lines.push('');
    // Side Performance
    if (data.sidePerformance.length > 0) {
        lines.push('### Side Performance');
        lines.push('');
        const sideHeaders = ['Map', 'Atk W/P', 'Atk WR', 'Def W/P', 'Def WR', 'Stronger'];
        const sideRows = data.sidePerformance.map(sp => [
            sp.map,
            `${sp.attackRoundsWon}/${sp.attackRoundsPlayed}`,
            formatPct(sp.attackWinRate),
            `${sp.defenseRoundsWon}/${sp.defenseRoundsPlayed}`,
            formatPct(sp.defenseWinRate),
            sp.strongerSide,
        ]);
        lines.push(renderTable(sideHeaders, sideRows));
        lines.push('');
    }
    // Pistol Performance
    if (data.pistolPerformance.length > 0) {
        lines.push('### Pistol Round Performance');
        lines.push('');
        const pistolHeaders = ['Map', 'W/P', 'WR', 'Atk WR', 'Def WR', 'Map WR|Win', 'Map WR|Loss'];
        const pistolRows = data.pistolPerformance.map(pp => [
            pp.map,
            `${pp.pistolRoundsWon}/${pp.pistolRoundsPlayed}`,
            formatPct(pp.pistolWinRate),
            formatPct(pp.attackPistolWinRate),
            formatPct(pp.defensePistolWinRate),
            formatPct(pp.mapWinRateGivenPistolWin),
            formatPct(pp.mapWinRateGivenPistolLoss),
        ]);
        lines.push(renderTable(pistolHeaders, pistolRows));
        lines.push('');
    }
    // Streak Stats
    if (data.streakStats.length > 0) {
        lines.push('### Win Streak Analysis');
        lines.push('');
        const streakHeaders = ['Map', 'Max', 'Avg', '2-Round', '3-Round', '4+ Round'];
        const streakRows = data.streakStats.map(ss => [
            ss.map,
            String(ss.maxStreak),
            ss.avgStreakLength.toFixed(1),
            String(ss.twoRoundStreaks),
            String(ss.threeRoundStreaks),
            String(ss.fourPlusStreaks),
        ]);
        lines.push(renderTable(streakHeaders, streakRows));
        lines.push('');
    }
    // Conditional Signals
    if (data.conditionalSignals.length > 0) {
        lines.push('### Map Win Signals');
        lines.push('');
        const signalHeaders = ['Map', 'WR|Pistol Win', 'WR|Post-Pistol Win', 'WR|Early Streak'];
        const signalRows = data.conditionalSignals.map(cs => [
            cs.map,
            `${formatPct(cs.mapWinRateGivenPistolWin)} (${cs.samples.pistolWins})`,
            `${formatPct(cs.mapWinRateGivenPostPistolWin)} (${cs.samples.postPistolWins})`,
            `${formatPct(cs.mapWinRateGivenEarlyStreak)} (${cs.samples.earlyStreaks})`,
        ]);
        lines.push(renderTable(signalHeaders, signalRows));
        lines.push('');
    }
    // Heat Zones
    if (data.heatZones.length > 0) {
        lines.push('### Heat Zones (Round Ranges)');
        lines.push('');
        const heatHeaders = ['Round Range', 'Win Rate', 'Streak Start', 'Streak End', 'Significance'];
        const heatRows = data.heatZones.map(hz => [
            hz.roundRange,
            formatPct(hz.winRate),
            formatPct(hz.streakStartRate),
            formatPct(hz.streakEndRate),
            hz.significance,
        ]);
        lines.push(renderTable(heatHeaders, heatRows));
        lines.push('');
    }
    return lines.join('\n');
}
function renderEconIntel(data) {
    const lines = [];
    // Aggregated Economy
    lines.push('### Aggregated Economy (all maps)');
    lines.push('');
    lines.push(`- **Avg Confidence**: ${formatPct(data.aggregated.avgEconConfidence)}`);
    lines.push(`- **Buy Distribution**: ECO ${formatPct(data.aggregated.buyDistribution.ECO)} | HALF ${formatPct(data.aggregated.buyDistribution.HALF_BUY)} | FULL ${formatPct(data.aggregated.buyDistribution.FULL_BUY)}`);
    lines.push(`- **Econ States**: BROKE ${formatPct(data.aggregated.econDistribution.BROKE)} | LOW ${formatPct(data.aggregated.econDistribution.LOW)} | OK ${formatPct(data.aggregated.econDistribution.OK)} | RICH ${formatPct(data.aggregated.econDistribution.RICH)}`);
    lines.push('');
    // Per-map details
    for (const mapSummary of data.mapSummaries) {
        lines.push(`### ${mapSummary.mapName}`);
        lines.push('');
        // Side Win Rates
        lines.push('**Side Win Rates**');
        lines.push('');
        const sideHeaders = ['Side', 'Win Rate', 'Rounds'];
        const sideRows = [
            ['Attack', formatPct(mapSummary.sideWinRates.attack), String(mapSummary.sideWinRates.attackRounds)],
            ['Defense', formatPct(mapSummary.sideWinRates.defense), String(mapSummary.sideWinRates.defenseRounds)],
        ];
        lines.push(renderTable(sideHeaders, sideRows));
        lines.push('');
        // Round Type Win Rates
        lines.push('**Round Type Win Rates**');
        lines.push('');
        const roundHeaders = ['Round Type', 'Win Rate', 'Played'];
        const roundRows = [
            ['Pistol (R1, R13)', formatPct(mapSummary.roundTypeWinRates.pistol), String(mapSummary.roundTypeWinRates.pistolPlayed)],
            ['Post-Pistol (R2, R14)', formatPct(mapSummary.roundTypeWinRates.postPistol), String(mapSummary.roundTypeWinRates.postPistolPlayed)],
        ];
        lines.push(renderTable(roundHeaders, roundRows));
        lines.push('');
        // Economy Distribution
        lines.push('**Inferred Economy Distribution**');
        lines.push('');
        lines.push(`- Buy: ECO ${formatPct(mapSummary.econ.buyDistribution.ECO)} | HALF ${formatPct(mapSummary.econ.buyDistribution.HALF_BUY)} | FULL ${formatPct(mapSummary.econ.buyDistribution.FULL_BUY)}`);
        lines.push(`- State: BROKE ${formatPct(mapSummary.econ.econDistribution.BROKE)} | LOW ${formatPct(mapSummary.econ.econDistribution.LOW)} | OK ${formatPct(mapSummary.econ.econDistribution.OK)} | RICH ${formatPct(mapSummary.econ.econDistribution.RICH)}`);
        lines.push('');
        // Pause Recommendations
        if (mapSummary.pause.topRecommendations.length > 0) {
            lines.push('**Pause Windows (Decision Support)**');
            lines.push('');
            for (const pw of mapSummary.pause.topRecommendations) {
                lines.push(`- Before R${pw.beforeRound} (${pw.scoreContext}) - Score: ${pw.pauseScore} - ${pw.reason}`);
            }
            lines.push('');
        }
    }
    return lines.join('\n');
}
